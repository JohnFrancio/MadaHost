// backend/src/services/websocket.js
const WebSocket = require("ws");
const url = require("url");
const supabase = require("../config/supabase");

class WebSocketManager {
  constructor() {
    this.wss = null;
    this.clients = new Map(); // userId -> WebSocket connection
    this.userSessions = new Map(); // WebSocket -> userId
  }

  initialize(server) {
    this.wss = new WebSocket.Server({
      server,
      path: "/ws",
      verifyClient: (info) => {
        // Optionnel : v√©rification d'authentification
        console.log("üîç Nouvelle tentative de connexion WebSocket");
        return true;
      },
    });

    this.wss.on("connection", (ws, request) => {
      console.log("üîå Nouvelle connexion WebSocket √©tablie");

      // Envoyer un message de bienvenue imm√©diatement
      ws.send(
        JSON.stringify({
          type: "connection",
          message: "Connexion WebSocket √©tablie",
          timestamp: new Date().toISOString(),
        })
      );

      ws.on("message", async (message) => {
        try {
          const data = JSON.parse(message);
          console.log("üì® Message re√ßu via WebSocket:", data.type);
          await this.handleMessage(ws, data);
        } catch (error) {
          console.error("‚ùå Erreur traitement message WebSocket:", error);
          ws.send(
            JSON.stringify({
              type: "error",
              message: "Message invalide",
            })
          );
        }
      });

      ws.on("close", (code, reason) => {
        console.log(`üîå Connexion WebSocket ferm√©e (code: ${code})`);
        this.handleDisconnect(ws);
      });

      ws.on("error", (error) => {
        console.error("‚ùå Erreur WebSocket:", error);
        this.handleDisconnect(ws);
      });

      // Ping p√©riodique pour maintenir la connexion
      ws.isAlive = true;
      ws.on("pong", () => {
        ws.isAlive = true;
      });
    });

    // Ping toutes les 30 secondes pour maintenir les connexions actives
    this.pingInterval = setInterval(() => {
      this.wss.clients.forEach((ws) => {
        if (ws.isAlive === false) {
          console.log("üîå Connexion WebSocket inactive, fermeture");
          return ws.terminate();
        }

        ws.isAlive = false;
        ws.ping();
      });
    }, 30000);

    console.log("üåê Serveur WebSocket d√©marr√© sur /ws");
    console.log(`üìä WebSocket Server configur√© avec les options:`, {
      path: "/ws",
      clientTracking: true,
    });
  }

  async handleMessage(ws, data) {
    try {
      switch (data.type) {
        case "auth":
          await this.handleAuth(ws, data);
          break;

        case "join_conversation":
          await this.handleJoinConversation(ws, data);
          break;

        case "leave_conversation":
          this.handleLeaveConversation(ws, data);
          break;

        case "ping":
          ws.send(
            JSON.stringify({
              type: "pong",
              timestamp: new Date().toISOString(),
            })
          );
          break;

        default:
          console.log("ü§∑ Type de message WebSocket inconnu:", data.type);
          ws.send(
            JSON.stringify({
              type: "error",
              message: `Type de message inconnu: ${data.type}`,
            })
          );
      }
    } catch (error) {
      console.error("‚ùå Erreur dans handleMessage:", error);
      ws.send(
        JSON.stringify({
          type: "error",
          message: "Erreur interne du serveur",
        })
      );
    }
  }

  async handleAuth(ws, data) {
    try {
      const { userId, accessToken } = data;

      console.log(
        `üîê Tentative d'authentification WebSocket pour userId: ${userId}`
      );

      if (!userId) {
        ws.send(
          JSON.stringify({
            type: "auth_error",
            message: "ID utilisateur manquant",
          })
        );
        return;
      }

      // V√©rifier l'utilisateur en base
      const { data: user, error } = await supabase
        .from("users")
        .select("id, username, role")
        .eq("id", userId)
        .single();

      if (error || !user) {
        console.error("‚ùå Utilisateur non trouv√© pour WebSocket:", error);
        ws.send(
          JSON.stringify({
            type: "auth_error",
            message: "Utilisateur non trouv√©",
          })
        );
        return;
      }

      // Fermer l'ancienne connexion si elle existe
      const existingWs = this.clients.get(userId);
      if (existingWs && existingWs.readyState === WebSocket.OPEN) {
        console.log(
          `üîÑ Fermeture de l'ancienne connexion pour ${user.username}`
        );
        existingWs.close();
      }

      // Enregistrer la nouvelle connexion
      this.clients.set(userId, ws);
      this.userSessions.set(ws, {
        userId,
        username: user.username,
        role: user.role,
        connectedAt: new Date().toISOString(),
      });

      ws.send(
        JSON.stringify({
          type: "auth_success",
          user: { id: user.id, username: user.username, role: user.role },
          message: "Authentification r√©ussie",
        })
      );

      console.log(`‚úÖ Utilisateur ${user.username} authentifi√© via WebSocket`);

      // Envoyer le nombre de messages non lus
      await this.sendUnreadCount(userId);
    } catch (error) {
      console.error("‚ùå Erreur authentification WebSocket:", error);
      ws.send(
        JSON.stringify({
          type: "auth_error",
          message: "Erreur d'authentification",
        })
      );
    }
  }

  async handleJoinConversation(ws, data) {
    const session = this.userSessions.get(ws);
    if (!session) {
      ws.send(
        JSON.stringify({
          type: "error",
          message: "Non authentifi√©",
        })
      );
      return;
    }

    const { conversationId } = data;
    if (!conversationId) {
      ws.send(
        JSON.stringify({
          type: "error",
          message: "ID de conversation manquant",
        })
      );
      return;
    }

    console.log(
      `üë• ${session.username} rejoint la conversation ${conversationId}`
    );

    // V√©rifier l'acc√®s √† la conversation
    const hasAccess = await this.checkConversationAccess(
      session.userId,
      conversationId,
      session.role
    );
    if (!hasAccess) {
      ws.send(
        JSON.stringify({
          type: "error",
          message: "Acc√®s non autoris√© √† cette conversation",
        })
      );
      return;
    }

    // Marquer les messages comme lus
    await this.markMessagesAsRead(conversationId, session.userId);

    // Ajouter √† la conversation
    session.currentConversation = conversationId;

    ws.send(
      JSON.stringify({
        type: "conversation_joined",
        conversationId,
        message: "Conversation rejointe avec succ√®s",
      })
    );

    console.log(
      `‚úÖ ${session.username} a rejoint la conversation ${conversationId}`
    );
  }

  handleLeaveConversation(ws, data) {
    const session = this.userSessions.get(ws);
    if (!session) return;

    const { conversationId } = data;

    if (session.currentConversation === conversationId) {
      session.currentConversation = null;
    }

    ws.send(
      JSON.stringify({
        type: "conversation_left",
        conversationId: conversationId || session.currentConversation,
        message: "Conversation quitt√©e",
      })
    );

    console.log(`üëã ${session.username} a quitt√© la conversation`);
  }

  handleDisconnect(ws) {
    const session = this.userSessions.get(ws);
    if (session) {
      this.clients.delete(session.userId);
      this.userSessions.delete(ws);
      console.log(`üëã ${session.username} d√©connect√© du WebSocket`);
    }
  }

  // M√©thodes pour envoyer des notifications
  async notifyNewMessage(conversationId, message, senderId) {
    try {
      console.log(
        `üì¢ Notification nouveau message dans conversation ${conversationId}`
      );

      // R√©cup√©rer les participants de la conversation avec leurs r√¥les
      const { data: conversation } = await supabase
        .from("conversations")
        .select(
          `
        user_id, 
        admin_id,
        subject,
        priority,
        users!conversations_user_id_fkey(username, role),
        admin:users!conversations_admin_id_fkey(username, role)
      `
        )
        .eq("id", conversationId)
        .single();

      if (!conversation) {
        console.log("‚ö†Ô∏è Conversation non trouv√©e pour notification");
        return;
      }

      // R√©cup√©rer les infos de l'exp√©diteur
      const { data: sender } = await supabase
        .from("users")
        .select("username, role")
        .eq("id", senderId)
        .single();

      const participants = [conversation.user_id, conversation.admin_id].filter(
        Boolean
      );

      console.log(`üë• Participants √† notifier:`, participants);
      console.log(`üì® Exp√©diteur: ${sender?.username} (${sender?.role})`);
      console.log(`üö´ Exp√©diteur exclu:`, senderId);

      for (const participantId of participants) {
        if (participantId === senderId) {
          console.log(`‚è≠Ô∏è Skipping exp√©diteur ${participantId}`);
          continue;
        }

        const ws = this.clients.get(participantId);
        console.log(
          `üîç WebSocket pour ${participantId}:`,
          ws ? "CONNECT√â" : "NON CONNECT√â"
        );

        if (ws && ws.readyState === WebSocket.OPEN) {
          const session = this.userSessions.get(ws);
          const userType = session?.role === "admin" ? "ADMIN" : "USER";

          console.log(`‚úÖ Envoi notification √† ${userType} ${participantId}`);

          // Enrichir le message avec les infos du sender
          const enrichedMessage = {
            ...message,
            sender: {
              ...message.sender,
              role: sender?.role || "user",
            },
          };

          ws.send(
            JSON.stringify({
              type: "new_message",
              conversationId,
              message: enrichedMessage,
              metadata: {
                senderRole: sender?.role,
                conversationSubject: conversation.subject,
                priority: conversation.priority,
              },
            })
          );

          console.log(`‚úÖ Message notifi√© √† ${userType} ${participantId}`);
        } else {
          console.log(`‚ö†Ô∏è ${participantId} non connect√© via WebSocket`);
        }

        // Mettre √† jour le compteur de messages non lus
        await this.sendUnreadCount(participantId);
      }

      // CORRECTION: Si c'est un message d'utilisateur vers un ticket non assign√©,
      // ne pas envoyer de notification admin ici car c'est d√©j√† fait dans les routes
      if (sender?.role !== "admin" && !conversation.admin_id) {
        console.log(
          `üì¢ Message utilisateur vers ticket non assign√© - notification admin d√©j√† envoy√©e`
        );
      }
    } catch (error) {
      console.error("‚ùå Erreur notification nouveau message:", error);
    }
  }

  async notifyConversationUpdate(conversationId, updateType, updateData) {
    try {
      console.log(
        `üì¢ Notification mise √† jour conversation ${conversationId}: ${updateType}`
      );

      const { data: conversation } = await supabase
        .from("conversations")
        .select("user_id, admin_id")
        .eq("id", conversationId)
        .single();

      if (!conversation) return;

      const participants = [conversation.user_id, conversation.admin_id].filter(
        Boolean
      );

      for (const participantId of participants) {
        const ws = this.clients.get(participantId);
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({
              type: "conversation_update",
              conversationId,
              updateType,
              data: updateData,
            })
          );
        }
      }
    } catch (error) {
      console.error("‚ùå Erreur notification mise √† jour conversation:", error);
    }
  }

  async notifyAdmins(notification) {
    try {
      console.log(`üì¢ Notification admin: ${notification.title}`);

      // R√©cup√©rer tous les admins
      const { data: admins } = await supabase
        .from("users")
        .select("id")
        .eq("role", "admin");

      if (!admins) return;

      let notifiedCount = 0;
      for (const admin of admins) {
        const ws = this.clients.get(admin.id);
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({
              type: "admin_notification",
              ...notification,
            })
          );
          notifiedCount++;
        }
      }

      console.log(`‚úÖ ${notifiedCount} admins notifi√©s via WebSocket`);
    } catch (error) {
      console.error("‚ùå Erreur notification admins:", error);
    }
  }

  async sendUnreadCount(userId) {
    try {
      const ws = this.clients.get(userId);
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      console.log(`üîç Calcul messages non lus pour utilisateur ${userId}`);

      // Compter les messages non lus
      const { data: unreadMessages, error } = await supabase
        .from("messages")
        .select("id, conversation_id, conversations!inner(user_id, admin_id)")
        .eq("is_read", false)
        .neq("sender_id", userId);

      if (error) {
        console.error("‚ùå Erreur requ√™te messages non lus:", error);
        return;
      }

      console.log(`üìä Messages non lus trouv√©s:`, unreadMessages?.length || 0);

      if (!unreadMessages || unreadMessages.length === 0) {
        ws.send(JSON.stringify({ type: "unread_count", count: 0 }));
        console.log(
          `üìß Compteur envoy√© √† utilisateur ${userId}: 0 messages non lus`
        );
        return;
      }

      // R√©cup√©rer l'utilisateur pour conna√Ætre son r√¥le
      const { data: user } = await supabase
        .from("users")
        .select("role")
        .eq("id", userId)
        .single();

      // Filtrer selon le r√¥le
      let userUnreadMessages;
      if (user?.role === "admin") {
        // Les admins voient tous les messages non lus des conversations
        userUnreadMessages = unreadMessages.filter((msg) => {
          const conv = msg.conversations;
          return conv.admin_id === userId || conv.admin_id === null; // Messages assign√©s ou non assign√©s
        });
        console.log(
          `üëë Admin - Messages filtr√©s: ${userUnreadMessages.length}`
        );
      } else {
        // Les utilisateurs voient seulement leurs conversations
        userUnreadMessages = unreadMessages.filter((msg) => {
          const conv = msg.conversations;
          return conv.user_id === userId;
        });
        console.log(
          `üë§ Utilisateur - Messages filtr√©s: ${userUnreadMessages.length}`
        );
      }

      const unreadCount = userUnreadMessages.length;

      ws.send(
        JSON.stringify({
          type: "unread_count",
          count: unreadCount,
        })
      );

      console.log(
        `üìß Compteur envoy√© √† utilisateur ${userId}: ${unreadCount} messages non lus`
      );
    } catch (error) {
      console.error("‚ùå Erreur calcul messages non lus:", error);
    }
  }

  async checkConversationAccess(userId, conversationId, userRole) {
    try {
      const { data: conversation } = await supabase
        .from("conversations")
        .select("user_id, admin_id")
        .eq("id", conversationId)
        .single();

      if (!conversation) return false;

      return (
        conversation.user_id === userId ||
        conversation.admin_id === userId ||
        userRole === "admin"
      );
    } catch (error) {
      console.error("‚ùå Erreur v√©rification acc√®s conversation:", error);
      return false;
    }
  }

  async markMessagesAsRead(conversationId, userId) {
    try {
      const { error } = await supabase
        .from("messages")
        .update({ is_read: true })
        .eq("conversation_id", conversationId)
        .neq("sender_id", userId)
        .eq("is_read", false);

      if (error) {
        console.error("‚ùå Erreur marquage messages lus:", error);
      } else {
        console.log(
          `‚úÖ Messages marqu√©s comme lus pour conversation ${conversationId}`
        );
      }
    } catch (error) {
      console.error("‚ùå Erreur marquage messages lus:", error);
    }
  }

  // M√©thode pour obtenir les statistiques de connexions
  getStats() {
    return {
      connectedUsers: this.clients.size,
      totalConnections: this.userSessions.size,
      activeConnections: this.wss ? this.wss.clients.size : 0,
    };
  }

  // M√©thode pour fermer proprement le serveur WebSocket
  close() {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
    }

    if (this.wss) {
      this.wss.clients.forEach((ws) => {
        ws.close();
      });
      this.wss.close();
    }

    this.clients.clear();
    this.userSessions.clear();
    console.log("üîå Serveur WebSocket ferm√©");
  }
}

module.exports = new WebSocketManager();
