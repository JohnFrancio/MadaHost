// backend/server.js
const express = require("express");
const cors = require("cors");
const helmet = require("helmet");
const morgan = require("morgan");
const session = require("express-session");
const passport = require("passport");
require("dotenv").config();
const StaticServer = require("./src/services/staticServer");
const staticServer = new StaticServer();
const http = require("http");
const WebSocketManager = require("./src/services/websocket");
const { serve, setup } = require("./src/config/swagger");

const app = express();
const PORT = process.env.PORT || 3001;

// Configuration CORS am√©lior√©e AVEC WebSocket
const corsOptions = {
  origin: process.env.FRONTEND_URL || "http://localhost:5173",
  credentials: true,
  optionsSuccessStatus: 200,
  methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization", "Cookie"],
};

// Middlewares de s√©curit√© MODIFI√âS pour WebSocket
app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: [
          "'self'",
          "data:",
          "https:",
          "*.github.com",
          "*.githubusercontent.com",
        ],
        // AJOUT IMPORTANT: autoriser les connexions WebSocket
        connectSrc: [
          "'self'",
          "https://api.github.com",
          "ws://localhost:3001",
          "wss://localhost:3001",
        ],
      },
    },
    crossOriginEmbedderPolicy: false,
  })
);

app.use(cors(corsOptions));
app.use(morgan("combined"));
app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true }));

// Configuration des sessions s√©curis√©es
app.use(
  session({
    secret: process.env.SESSION_SECRET || "your-secret-key",
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: process.env.NODE_ENV === "production",
      httpOnly: true,
      maxAge: 24 * 60 * 60 * 1000, // 24 heures
      sameSite: process.env.NODE_ENV === "production" ? "none" : "lax",
    },
    name: "madahost.sid",
  })
);

// Configuration Passport
app.use(passport.initialize());
app.use(passport.session());

// Middleware de logging des sessions (d√©veloppement)
if (process.env.NODE_ENV !== "production") {
  app.use((req, res, next) => {
    // √âviter de logger les requ√™tes WebSocket dans les routes HTTP
    if (req.path !== "/ws") {
      console.log(`[${new Date().toISOString()}] ${req.method} ${req.path}`);
      console.log("Session ID:", req.sessionID);
      console.log("User:", req.user ? req.user.username : "non connect√©");
      console.log("---");
    }
    next();
  });
}

app.use("/api-docs", serve, setup);
app.get("/docs", (req, res) => {
  res.redirect("/api-docs");
});

app.get("/api", (req, res) => {
  res.json({
    name: "MadaHost API",
    version: "1.0.0",
    description: "API de d√©ploiement de sites web statiques avec GitHub",
    documentation: {
      swagger: `${req.protocol}://${req.get("host")}/api-docs`,
      postman: "https://documenter.getpostman.com/view/your-collection-id",
    },
    endpoints: {
      auth: "/auth",
      projects: "/projects",
      deployments: "/deployments",
      github: "/github",
      messages: "/messages",
      admin: "/admin",
    },
    status: "running",
  });
});

// Routes API
const { router: authRouter } = require("./src/routes/auth");
app.use("/api/auth", authRouter);

app.use("/api/projects", require("./src/routes/projects"));

const githubRoutes = require("./src/routes/github");
app.use("/api/github", githubRoutes);

const deploymentsRoutes = require("./src/routes/deployments.js");
app.use("/api/deployments", deploymentsRoutes);

const adminRoutes = require("./src/routes/admin");
app.use("/api/admin", adminRoutes);

const messageRoutes = require("./src/routes/messages");
app.use("/api/messages", messageRoutes);

// AJOUT: Route de diagnostic WebSocket
app.get("/api/ws-status", (req, res) => {
  const stats = WebSocketManager.getStats();
  res.json({
    status: "WebSocket server active",
    connectedUsers: stats.connectedUsers,
    totalConnections: stats.totalConnections,
    activeConnections: stats.activeConnections,
    timestamp: new Date().toISOString(),
  });
});

// Route de sant√© d√©taill√©e
app.get("/api/health", (req, res) => {
  const health = {
    status: "OK",
    timestamp: new Date().toISOString(),
    version: "1.0.0",
    environment: process.env.NODE_ENV || "development",
    uptime: process.uptime(),
    session: {
      connected: !!req.user,
      user: req.user ? req.user.username : null,
      sessionId: req.sessionID,
    },
    websocket: WebSocketManager.getStats(),
    config: {
      github: {
        clientId: !!process.env.GITHUB_CLIENT_ID,
        clientSecret: !!process.env.GITHUB_CLIENT_SECRET,
        callbackUrl: process.env.GITHUB_CALLBACK_URL,
      },
      supabase: {
        url: !!process.env.SUPABASE_URL,
        key: !!process.env.SUPABASE_SERVICE_ROLE_KEY,
      },
      session: {
        secret: !!process.env.SESSION_SECRET,
      },
    },
  };

  res.json(health);
});

// Route pour obtenir les infos utilisateur connect√© (version d√©taill√©e)
app.get("/api/user", (req, res) => {
  console.log("üîç Route /api/user appel√©e");
  console.log("üë§ User pr√©sent:", !!req.user);
  console.log("üì± Session ID:", req.sessionID);

  if (!req.user) {
    return res.status(401).json({
      error: "Non authentifi√©",
      authenticated: false,
      sessionExists: !!req.session,
    });
  }

  const response = {
    success: true,
    authenticated: true,
    user: {
      id: req.user.id,
      username: req.user.username,
      displayName: req.user.displayName,
      email: req.user.email,
      avatar: req.user.avatar_url,
      githubId: req.user.github_id,
      role: req.user.role, // AJOUT IMPORTANT: inclure le r√¥le
    },
    session: {
      id: req.sessionID,
      hasGithubToken: !!req.user.access_token,
      tokenPreview: req.user.access_token
        ? req.user.access_token.substring(0, 8) + "..."
        : null,
    },
  };

  console.log("‚úÖ R√©ponse user:", {
    username: response.user.username,
    role: response.user.role,
    hasToken: response.session.hasGithubToken,
  });

  res.json(response);
});

// Route de diagnostic des sessions
app.get("/api/debug/session", (req, res) => {
  if (process.env.NODE_ENV === "production") {
    return res
      .status(403)
      .json({ error: "Debug non disponible en production" });
  }

  res.json({
    session: {
      id: req.sessionID,
      data: req.session,
      cookie: req.session.cookie,
    },
    user: req.user || null,
    websocket: WebSocketManager.getStats(),
    headers: {
      userAgent: req.headers["user-agent"],
      origin: req.headers.origin,
      referer: req.headers.referer,
      cookie: req.headers.cookie,
    },
  });
});

// IMPORTANT: Cr√©er le serveur HTTP AVANT de d√©finir les middlewares de fin
const server = http.createServer(app);

// CRITIQUE: Initialiser WebSocket AVANT server.listen()
console.log("üîß Initialisation du serveur WebSocket...");
WebSocketManager.initialize(server);

// Middleware de gestion d'erreurs global am√©lior√©
app.use((err, req, res, next) => {
  console.error("‚ùå Erreur serveur:", err);
  console.error("üìç Stack:", err.stack);
  console.error("üîç URL:", req.url);
  console.error("üë§ User:", req.user ? req.user.username : "non connect√©");

  // Erreurs sp√©cifiques
  if (err.code === "EBADCSRFTOKEN") {
    return res.status(403).json({
      success: false,
      error: "Token CSRF invalide",
    });
  }

  if (err.type === "entity.too.large") {
    return res.status(413).json({
      success: false,
      error: "Fichier trop volumineux",
    });
  }

  res.status(err.status || 500).json({
    success: false,
    error:
      process.env.NODE_ENV === "production"
        ? "Une erreur est survenue"
        : err.message,
    ...(process.env.NODE_ENV !== "production" && {
      stack: err.stack,
      details: {
        url: req.url,
        method: req.method,
        user: req.user?.username || null,
        timestamp: new Date().toISOString(),
      },
    }),
  });
});

// Middleware pour les routes non trouv√©es
app.use("*", (req, res) => {
  // Ne pas logger les tentatives WebSocket comme des 404
  if (!req.originalUrl.includes("/ws")) {
    console.log(`üîç Route non trouv√©e: ${req.method} ${req.originalUrl}`);
  }
  res.status(404).json({
    success: false,
    error: "Route non trouv√©e",
    path: req.originalUrl,
    method: req.method,
  });
});

// D√©marrage du serveur avec v√©rifications
server.listen(PORT, async () => {
  console.log("üöÄ Serveur MadaHost d√©marr√© !");
  console.log(`üîó API disponible sur: http://localhost:${PORT}`);
  console.log(`üåê WebSocket disponible sur: ws://localhost:${PORT}/ws`);
  console.log(
    `üåê Frontend sur: ${process.env.FRONTEND_URL || "http://localhost:5173"}`
  );
  console.log(`üèóÔ∏è Environnement: ${process.env.NODE_ENV || "development"}`);

  // D√©marrer le serveur statique
  try {
    await staticServer.start();
    console.log(
      `üì° Serveur statique sur: http://localhost:${
        process.env.STATIC_PORT || 3002
      }`
    );
  } catch (error) {
    console.error("‚ùå Erreur d√©marrage serveur statique:", error);
  }

  // V√©rifications de configuration
  const missingConfig = [];

  if (!process.env.GITHUB_CLIENT_ID) missingConfig.push("GITHUB_CLIENT_ID");
  if (!process.env.GITHUB_CLIENT_SECRET)
    missingConfig.push("GITHUB_CLIENT_SECRET");
  if (!process.env.SUPABASE_URL) missingConfig.push("SUPABASE_URL");
  if (!process.env.SUPABASE_SERVICE_ROLE_KEY)
    missingConfig.push("SUPABASE_SERVICE_ROLE_KEY");
  if (!process.env.SESSION_SECRET) missingConfig.push("SESSION_SECRET");

  if (missingConfig.length > 0) {
    console.warn("‚ö†Ô∏è Configuration manquante:", missingConfig.join(", "));
    console.warn("üîß V√©rifiez votre fichier .env");
  } else {
    console.log("‚úÖ Configuration compl√®te");
  }

  console.log("üéØ Routes disponibles:");
  console.log("  - GET  /api/health");
  console.log("  - GET  /api/user");
  console.log("  - GET  /api/ws-status");
  console.log("  - WS   /ws (WebSocket)");
  console.log("  - GET  /api/auth/github");
  console.log("  - GET  /api/auth/me");
  console.log("  - GET  /api/github/repos");
  console.log("  - GET  /api/github/test");
  console.log("  - GET  /api/projects");
  console.log("  - GET  /api/messages/*");
  console.log("");
  console.log("üì° Serveur statique:");
  console.log(
    `  - GET  http://localhost:${
      process.env.STATIC_PORT || 3002
    }/project/:projectId/*`
  );
  console.log(
    `  - GET  http://projet.localhost:${process.env.STATIC_PORT || 3002}/`
  );
  console.log("");

  // Afficher les statistiques WebSocket
  const wsStats = WebSocketManager.getStats();
  console.log("üìä WebSocket Status:");
  console.log(`  - Connexions actives: ${wsStats.activeConnections}`);
  console.log(`  - Utilisateurs connect√©s: ${wsStats.connectedUsers}`);
  console.log("");

  console.log("‚úÖ Serveur pr√™t √† recevoir les requ√™tes");

  // Test de connectivit√© Supabase
  if (process.env.SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY) {
    const { createClient } = require("@supabase/supabase-js");
    const supabase = createClient(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );

    supabase
      .from("users")
      .select("count", { count: "exact", head: true })
      .then(({ count, error }) => {
        if (error) {
          console.warn("‚ö†Ô∏è Connexion Supabase √©chou√©e:", error.message);
        } else {
          console.log("‚úÖ Connexion Supabase OK -", count, "utilisateurs");
        }
      })
      .catch((err) => {
        console.warn("‚ö†Ô∏è Test Supabase √©chou√©:", err.message);
      });
  }
});

// CORRECTION: Fonctions de shutdown am√©lior√©es
const gracefulShutdown = async () => {
  console.log("\nüõë Arr√™t des serveurs...");

  try {
    // Fermer WebSocket proprement
    if (WebSocketManager) {
      WebSocketManager.close();
    }

    // Fermer le serveur statique
    staticServer.stop();

    // Fermer le serveur HTTP
    server.close((err) => {
      if (err) {
        console.error("‚ùå Erreur fermeture serveur:", err);
        process.exit(1);
      } else {
        console.log("‚úÖ Serveur ferm√© proprement");
        process.exit(0);
      }
    });
  } catch (error) {
    console.error("‚ùå Erreur lors de l'arr√™t:", error);
    process.exit(1);
  }
};

// Gestion propre de l'arr√™t du serveur
process.on("SIGINT", gracefulShutdown);
process.on("SIGTERM", gracefulShutdown);

process.on("uncaughtException", (err) => {
  console.error("üí• Exception non g√©r√©e:", err);
  process.exit(1);
});

process.on("unhandledRejection", (reason, promise) => {
  console.error("üí• Promise rejet√©e non g√©r√©e:", reason);
  console.error("Promise:", promise);
  process.exit(1);
});
